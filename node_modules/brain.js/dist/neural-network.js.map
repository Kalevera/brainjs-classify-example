{"version":3,"sources":["../src/neural-network.js"],"names":["NeuralNetwork","options","learningRate","momentum","hiddenSizes","hiddenLayers","binaryThresh","sizes","outputLayer","biases","weights","outputs","deltas","changes","errors","keepNetworkIntact","length","layer","size","Array","node","prevSize","input","inputLookup","toArray","output","runInput","outputLookup","toHash","sum","k","Math","exp","data","formatData","iterations","errorThresh","log","console","logPeriod","callback","callbackPeriod","inputSize","outputSize","push","max","floor","forEach","unshift","initialize","error","i","j","err","trainPattern","target","calculateDeltas","adjustWeights","incoming","delta","change","constructor","tmp","datum","Float64Array","buildLookup","map","value","array","Object","assign","isBinary","falsePos","falseNeg","truePos","trueNeg","misclasses","actual","expected","indexOf","misclass","stats","total","precision","recall","accuracy","layers","nodes","keys","bias","index","json","lookupFromHash","toJSON","jsonString","JSON","stringify","Function","opts","neuralNetwork","trainStream"],"mappings":"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","file":"neural-network.js","sourcesContent":["import lookup from './lookup';\nimport TrainStream from './train-stream';\nimport max from './utilities/max';\nimport mse from './utilities/mse';\nimport randos from './utilities/randos';\nimport range from './utilities/range';\nimport toArray from './utilities/to-array';\nimport zeros from './utilities/zeros';\n\n/**\n *\n * @param {object} options\n * @constructor\n */\nexport default class NeuralNetwork {\n  constructor(options) {\n    options = options || {};\n    this.learningRate = options.learningRate || 0.3;\n    this.momentum = options.momentum || 0.1;\n    this.hiddenSizes = options.hiddenLayers;\n\n    this.binaryThresh = options.binaryThresh || 0.5;\n\n    this.sizes = null;\n    this.outputLayer = null;\n    this.biases = null; // weights for bias nodes\n    this.weights = null;\n    this.outputs = null;\n\n    // state for training\n    this.deltas = null;\n    this.changes = null; // for momentum\n    this.errors = null;\n  }\n\n  /**\n   *\n   * @param {} sizes\n   * @param {Boolean} keepNetworkIntact\n   */\n  initialize(sizes, keepNetworkIntact) {\n    this.sizes = sizes;\n    this.outputLayer = this.sizes.length - 1;\n\n    if (!keepNetworkIntact) {\n      this.biases = []; // weights for bias nodes\n      this.weights = [];\n      this.outputs = [];\n    }\n\n    // state for training\n    this.deltas = [];\n    this.changes = []; // for momentum\n    this.errors = [];\n\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      let size = this.sizes[layer];\n      this.deltas[layer] = zeros(size);\n      this.errors[layer] = zeros(size);\n      if (!keepNetworkIntact) {\n        this.outputs[layer] = zeros(size);\n      }\n\n      if (layer > 0) {\n        this.biases[layer] = randos(size);\n        if (!keepNetworkIntact) {\n          this.weights[layer] = new Array(size);\n        }\n        this.changes[layer] = new Array(size);\n\n        for (let node = 0; node < size; node++) {\n          let prevSize = this.sizes[layer - 1];\n          if (!keepNetworkIntact) {\n            this.weights[layer][node] = randos(prevSize);\n          }\n          this.changes[layer][node] = zeros(prevSize);\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input);\n    }\n\n    let output = this.runInput(input);\n\n    if (this.outputLookup) {\n      output = lookup.toHash(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    this.outputs[0] = input;  // set output state of input layer\n\n    let output = null;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let weights = this.weights[layer][node];\n\n        let sum = this.biases[layer][node];\n        for (let k = 0; k < weights.length; k++) {\n          sum += weights[k] * input[k];\n        }\n        this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));\n      }\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @returns {{error: number, iterations: number}}\n   */\n  train(data, options) {\n    data = this.formatData(data);\n\n    options = options || {};\n    let iterations = options.iterations || 20000;\n    let errorThresh = options.errorThresh || 0.005;\n    let log = options.log ? (typeof options.log === 'function' ? options.log : console.log) : false;\n    let logPeriod = options.logPeriod || 10;\n    let learningRate = options.learningRate || this.learningRate || 0.3;\n    let callback = options.callback;\n    let callbackPeriod = options.callbackPeriod || 10;\n    let sizes = [];\n    let inputSize = data[0].input.length;\n    let outputSize = data[0].output.length;\n    let hiddenSizes = this.hiddenSizes;\n    if (!hiddenSizes) {\n      sizes.push(Math.max(3, Math.floor(inputSize / 2)));\n    } else {\n      hiddenSizes.forEach(size => {\n        sizes.push(size);\n      });\n    }\n\n    sizes.unshift(inputSize);\n    sizes.push(outputSize);\n\n    this.initialize(sizes, options.keepNetworkIntact);\n\n    let error = 1;\n    let i;\n    for (i = 0; i < iterations && error > errorThresh; i++) {\n      let sum = 0;\n      for (let j = 0; j < data.length; j++) {\n        let err = this.trainPattern(data[j].input, data[j].output, learningRate);\n        sum += err;\n      }\n      error = sum / data.length;\n\n      if (log && (i % logPeriod == 0)) {\n        log('iterations:', i, 'training error:', error);\n      }\n      if (callback && (i % callbackPeriod == 0)) {\n        callback({ error: error, iterations: i });\n      }\n    }\n\n    return {\n      error: error,\n      iterations: i\n    };\n  }\n\n  /**\n   *\n   * @param input\n   * @param target\n   * @param learningRate\n   */\n  trainPattern(input, target, learningRate) {\n    learningRate = learningRate || this.learningRate;\n\n    // forward propagate\n    this.runInput(input);\n\n    // back propagate\n    this.calculateDeltas(target);\n    this.adjustWeights(learningRate);\n\n    let error = mse(this.errors[this.outputLayer]);\n    return error;\n  }\n\n  /**\n   *\n   * @param target\n   */\n  calculateDeltas(target) {\n    for (let layer = this.outputLayer; layer >= 0; layer--) {\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let output = this.outputs[layer][node];\n\n        let error = 0;\n        if (layer == this.outputLayer) {\n          error = target[node] - output;\n        }\n        else {\n          let deltas = this.deltas[layer + 1];\n          for (let k = 0; k < deltas.length; k++) {\n            error += deltas[k] * this.weights[layer + 1][k][node];\n          }\n        }\n        this.errors[layer][node] = error;\n        this.deltas[layer][node] = error * output * (1 - output);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param learningRate\n   */\n  adjustWeights(learningRate) {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      let incoming = this.outputs[layer - 1];\n\n      for (let node = 0; node < this.sizes[layer]; node++) {\n        let delta = this.deltas[layer][node];\n\n        for (let k = 0; k < incoming.length; k++) {\n          let change = this.changes[layer][node][k];\n\n          change = (learningRate * delta * incoming[k])\n            + (this.momentum * change);\n\n          this.changes[layer][node][k] = change;\n          this.weights[layer][node][k] += change;\n        }\n        this.biases[layer][node] += learningRate * delta;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {*}\n   */\n  formatData(data) {\n    if (data.constructor !== Array) { // turn stream datum into array\n      let tmp = [];\n      tmp.push(data);\n      data = tmp;\n    }\n    // turn sparse hash input into arrays with 0s as filler\n    let datum = data[0].input;\n    if (datum.constructor !== Array && !(datum instanceof Float64Array)) {\n      if (!this.inputLookup) {\n        this.inputLookup = lookup.buildLookup(data.map(value => value['input']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.inputLookup, datum.input);\n        return Object.assign({}, datum, { input: array });\n      }, this);\n    }\n\n    if (data[0].output.constructor !== Array) {\n      if (!this.outputLookup) {\n        this.outputLookup = lookup.buildLookup(data.map(value => value['output']));\n      }\n      data = data.map(datum => {\n        let array = lookup.toArray(this.outputLookup, datum.output);\n        return Object.assign({}, datum, { output: array });\n      }, this);\n    }\n    return data;\n  }\n\n  /**\n   *\n   * @param data\n   * @returns {\n   *  {\n   *    error: number,\n   *    misclasses: Array\n   *  }\n   * }\n   */\n  test(data) {\n    data = this.formatData(data);\n\n    // for binary classification problems with one output node\n    let isBinary = data[0].output.length == 1;\n    let falsePos = 0;\n    let falseNeg = 0;\n    let truePos = 0;\n    let trueNeg = 0;\n\n    // for classification problems\n    let misclasses = [];\n\n    // run each pattern through the trained network and collect\n    // error and misclassification statistics\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      let output = this.runInput(data[i].input);\n      let target = data[i].output;\n\n      let actual, expected;\n      if (isBinary) {\n        actual = output[0] > this.binaryThresh ? 1 : 0;\n        expected = target[0];\n      }\n      else {\n        actual = output.indexOf(max(output));\n        expected = target.indexOf(max(target));\n      }\n\n      if (actual != expected) {\n        let misclass = data[i];\n        Object.assign(misclass, {\n          actual: actual,\n          expected: expected\n        });\n        misclasses.push(misclass);\n      }\n\n      if (isBinary) {\n        if (actual == 0 && expected == 0) {\n          trueNeg++;\n        }\n        else if (actual == 1 && expected == 1) {\n          truePos++;\n        }\n        else if (actual == 0 && expected == 1) {\n          falseNeg++;\n        }\n        else if (actual == 1 && expected == 0) {\n          falsePos++;\n        }\n      }\n\n      let errors = output.map((value, i) => {\n        return target[i] - value;\n      });\n      sum += mse(errors);\n    }\n    let error = sum / data.length;\n\n    let stats = {\n      error: error,\n      misclasses: misclasses\n    };\n\n    if (isBinary) {\n      Object.assign(stats, {\n        trueNeg: trueNeg,\n        truePos: truePos,\n        falseNeg: falseNeg,\n        falsePos: falsePos,\n        total: data.length,\n        precision: truePos / (truePos + falsePos),\n        recall: truePos / (truePos + falseNeg),\n        accuracy: (trueNeg + truePos) / data.length\n      });\n    }\n    return stats;\n  }\n\n  /**\n   *\n   * @returns\n   *  {\n   *    layers: [\n   *      {\n   *        x: {},\n   *        y: {}\n   *      },\n   *      {\n   *        '0': {\n   *          bias: -0.98771313,\n   *          weights: {\n   *            x: 0.8374838,\n   *            y: 1.245858\n   *          },\n   *        '1': {\n   *          bias: 3.48192004,\n   *          weights: {\n   *            x: 1.7825821,\n   *            y: -2.67899\n   *          }\n   *        }\n   *      },\n   *      {\n   *        f: {\n   *          bias: 0.27205739,\n   *          weights: {\n   *            '0': 1.3161821,\n   *            '1': 2.00436\n   *          }\n   *        }\n   *      }\n   *    ]\n   *  }\n   */\n  toJSON() {\n    let layers = [];\n    for (let layer = 0; layer <= this.outputLayer; layer++) {\n      layers[layer] = {};\n\n      let nodes;\n      // turn any internal arrays back into hashes for readable json\n      if (layer == 0 && this.inputLookup) {\n        nodes = Object.keys(this.inputLookup);\n      }\n      else if (layer == this.outputLayer && this.outputLookup) {\n        nodes = Object.keys(this.outputLookup);\n      }\n      else {\n        nodes = range(0, this.sizes[layer]);\n      }\n\n      for (let j = 0; j < nodes.length; j++) {\n        let node = nodes[j];\n        layers[layer][node] = {};\n\n        if (layer > 0) {\n          layers[layer][node].bias = this.biases[layer][j];\n          layers[layer][node].weights = {};\n          for (let k in layers[layer - 1]) {\n            let index = k;\n            if (layer == 1 && this.inputLookup) {\n              index = this.inputLookup[k];\n            }\n            layers[layer][node].weights[k] = this.weights[layer][j][index];\n          }\n        }\n      }\n    }\n    return { layers: layers, outputLookup:!!this.outputLookup, inputLookup:!!this.inputLookup };\n  }\n\n  /**\n   *\n   * @param json\n   * @returns {NeuralNetwork}\n   */\n  fromJSON(json) {\n    let size = json.layers.length;\n    this.outputLayer = size - 1;\n\n    this.sizes = new Array(size);\n    this.weights = new Array(size);\n    this.biases = new Array(size);\n    this.outputs = new Array(size);\n\n    for (let i = 0; i <= this.outputLayer; i++) {\n      let layer = json.layers[i];\n      if (i == 0 && (!layer[0] || json.inputLookup)) {\n        this.inputLookup = lookup.lookupFromHash(layer);\n      }\n      else if (i == this.outputLayer && (!layer[0] || json.outputLookup)) {\n        this.outputLookup = lookup.lookupFromHash(layer);\n      }\n\n      let nodes = Object.keys(layer);\n      this.sizes[i] = nodes.length;\n      this.weights[i] = [];\n      this.biases[i] = [];\n      this.outputs[i] = [];\n\n      for (let j in nodes) {\n        let node = nodes[j];\n        this.biases[i][j] = layer[node].bias;\n        this.weights[i][j] = toArray(layer[node].weights);\n      }\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @returns {Function}\n   */\n  toFunction() {\n    const json = this.toJSON();\n    const jsonString = JSON.stringify(json);\n    // return standalone function that mimics run()\n    return new Function('input', `\n      var net = ${ jsonString };\n      for (var i = 1; i < net.layers.length; i++) {\n        var layer = net.layers[i];\n        var output = {};\n        \n        for (var id in layer) {\n          var node = layer[id];\n          var sum = node.bias;\n          \n          for (var iid in node.weights) {\n            sum += node.weights[iid] * input[iid];\n          }\n          output[id] = (1 / (1 + Math.exp(-sum)));\n        }\n        input = output;\n      }\n      return output;\n    `);\n  }\n\n  /**\n   * This will create a TrainStream (WriteStream) for us to send the training data to.\n   * @param opts training options\n   * @returns {TrainStream|*}\n   */\n  createTrainStream(opts) {\n    opts = opts || {};\n    opts.neuralNetwork = this;\n    this.trainStream = new TrainStream(opts);\n    return this.trainStream;\n  }\n}\n"]}